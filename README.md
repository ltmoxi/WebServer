这是一个练手的项目,实现一个简单的web容器

# v1 创建一个服务端 实现方法:readLine

该方法可以读取一行字符串因为一个请求中的请求行和消息头都是一行一行的字符串(以CRLF结尾).

在ClientHandler类中定义readLine方法,并测试其读取一行的功能

# v2 简单的解析请求

将客户端发送过来的请求以一个HttpRequest对象的形式保存,以便后期处理时可以方便的取到请求中各个信息.

#### 实现方法:
1. 新建一个包com.webserver.http
2. 在该包中定义一个类HttpRequest
3. 在该类中定义请求中各部分信息对应的属性
4. 定义构造方法来初始化(解析请求)

# v4 用户输入地址后可正确请求到网页资源
当用户在浏览器访问一个页面时,输入路径如:  
http://localhost:8008/myweb/index.html  

我们在请求中得到抽象路径部分:myweb/index.html  
但这是要给典型的相对路径,我们要在服务端中定义该路径相对的位置,以便找到该资源

在当前项目目录下新建要给目录webapps,用这个目录保存每一个在服务器上运行的web应用.  
一个web应用简单说就是一个网站的一切内容,包含素材(网页,图片,样式等)和业务逻辑

webapps下面用一个子目录保存一个web应用,现在其下创建一个名为myweb的目录,用作我们测试使用.

在webapps/myweb目录下新建第一个页面:index.html

当用户在浏览器输入  
http://localhost:8008/myweb/index.html  
时我们得到抽象路径:/myweb/index.html后,我们就从webapps目录作为相对的当前目录开始,就可以找到对应资源了

在ClientHandler中当通过请求中的资源路径到webapps目录下找到对应资源后,发送一个响应内容回复客户端

# v5 重构v4


进行功能拆分,将实际响应客户端的工作从ClientHandler中抽离出去,宗旨还是让ClientHandler只控制流程,具体操作分开

与httpRequest的设计目的类似,我们在http包中再定义一个类:HttpResponse,用这个类的每一个实例表示一个服务端具体发送给客户端的响应内容

# v6 使服务端支持响应不同类型资源给客户端.


当用户请求一个页面时,服务端将该页面的html代码响应回去后,浏览器解析时若发现该页面存在图片时,会再次发起连接向服务器请求图片资源,这时服务端应当将该图片响应回去.  
所以当一个页面中存在其他资源时,构成这个页面会经历数次请求响应来完成.

但是如果希望浏览器能正确理解其请求的资源,要求服务端在响应该资源时在响应头中指定的Content-Type必须准确.  
不同的资源的类型有不同的值,这些都是有定义的.  
我们可以参考tomcat安装目录中conf目录中的web.xml文件,该文件整理出了这些类型,有一千多个

修改HttpResponse,首先发送的响应头不能是固定值,该根据实际响应需求进行变化

1. 在HttpResponse中定义响应头相关属性:Map headers,并且对外提供设置响应头和获取响应头信息的相关方法.

2. 修改发送响应头方法,将原来固定发送两个响应头:Content-Type和Content-Length改变为遍历headers,将每个响应头进行发送

3. 在http包中定义一个类:HttpContext,使用这个类来定义所有有关HTTP协议的内容  
这里先定义相关Content-Type对应值的一组信息  
3.1 定义一个私有的静态属性:mimeTypeMapping,其中key保存资源后缀名,value保存mime类型(Content-Type)  
3.2 定义一个私有的静态方法用来初始化这个Map  
3.3 在HttpContext的静态块中调用这个初始化方法来进行初始化操作  
3.4 定义一个共有的静态方法: getMimeType,该方法可以根据文件后缀名来获取对应mime类型

4. 修改HttpResponse的setEntity方法,在该方法中除了将给定的File文件设置到对应属性entity之外,再根据该文件向响应头对应的Map属性headers中添加Content-Type与Content-Length其中的Content-Type的值要根据该文件后缀调用3.4的方法获取对应的值

# v7 解决空请求问题  

Http协议有说明这种情况,允许客户端连接服务端后发送空请求实际并没有发送标准的请求内容.

对于我们现阶段代码而言,ClientHandler做的第一部就是解析请求,而请求对象HttpRequest实例化时一定会开始解析工作顺序解析请求行,消息头,消息正文.然后若客户端发送的是空请求,则在解析请求行获取其中三部分信息method,url,protocol时由于拆分不出三项,会导致下标越界报错.

解决办法:当解析请求行时遇到空请求时,直接向ClientHandler抛出空请求异常(一个自定义异常),当ClientHandler接收到该异常后忽略本次处理客户端的后续操作

1. 在com.webserver.http包中定义一个类:EmptyRequestException,使用这个类的实例表示一个空请求异常
2. 在HttpRequest解析请求行的方法:parseRequestLine中当读取请求行后,添加判断,若这行字符串是一个空字符串,则这个请求是一个空请求,那么就实例化一个空请求异常并将其抛出
3. 在HttpRequest的构造方法中继续声明将空请求异常抛出
4. 在ClientHandler中,添加一个catch,单独捕获空请求异常,这样当实例化HttpRequest解析请求时若其构造方法抛出该异常则跳过后续处理请求的所有步骤,直接与客户端断开连接即可

# v8 支持tomcat中所有的介质类型

tomcat的安装目录中的conf目录里有一个web.xml文件,该文件中整理了所有Content-Type所支持的值,我们将他们解析出来用于初始化HttpContext类中的mimeTypeMapping

1. 在当前项目目录下新建一个目录conf
2. 即将tomcat安装目录中conf/web.xml拷贝到我们的conf目录中
3. 修改HttpContext初始化mimeTypeMapping的方法:initMimeTypeMapping()  
将原有直接向mimeTypeMapping这个Map中put元素的代码全部删除,改为通过解析conf/web.xml中所有的mime来完成初始化

# v9 添加响应404页面的功能  

当用户请求的地址无效时,服务端要向客户端响应404错误.

当前HttpResponse发送状态行时,状态代码和对应描述时固定的信息为200 OK,因此我们要将状态代码也改为可以进行设置的,但出于方便(大部分请求应当都是正常的),我们可以有默认值200　OK这样大部分响应就无需都设置状态代码了.

1. 在HttpResponse中添加两个属性:  
int statusCode,String statusReason  
默认值分别为200,"OK"
2. 修改和发送状态行的方法:sendStatusLine,将原有的固定发送改为根据这两个属性发送　
当用户请求路径有误时,我们需要做以下操作:  
响应中的状态代码应改为404,状态描述变为NOT FOUND,并且响应正文的内容为一个404页面.  
由于不同的状态代码有这对应的状态描述(HTTP协议有建议值),我们可以在HttpContext类中再定义一个Map,key保存状态代码,value保存建议的状态描述.  
然后当我们调用HttpResponse设置状态代码的方法来设置状态代码时,可以根据状态代码来找到对应的状态描述并自动进行设置(由于我们提供了单独设置状态的set方法,所以若不想用建议值,也可以在设置完状态代码后再单独设置状态描述,但通常不需要这么做)

3. 在HttpContext中定义一个Map属性:statusCodeReasonMapping
4. 再定义一个静态方法,可根据状态代码获取对应状态描述
5. 再定义一个静态方法用于初始化这个Map,并再HttpContext的静态块中执行来完成初始化操作
6. 修改HttpResponse设置状态代码的方法,添加额外逻辑,根据设置的状态代码从HttpContext中获取对应的状态描述,并自动设置到对应属性上  
404页面应当是一个公共页面,无论哪个网络应用都可能会出现用户请求的路径不对,导致要响应该页面.  
对子我们讲次页面单独存放在一个公共目录里

7. 在webapps下新建一个目录:root,用这个目录存放公共资源
8. 在root下新建一个404xml

# v10 使得服务端支持客户端传递用户输入的数据


我们日常上网,经常会在页面上输入信息,比如注册操作.输入后点击按钮提交给服务端.这个过程的实现如下:
1. 首先要想让用户可以输入内容,当用户输入信息后点击提交按钮,然后将这个表单内容提交.
2. 当表单提交后,服务端应当在解析请求时,将用户提交的这些数据解析出来,以便做后续对应的操作

实现:
1. 准备一个注册页面,测试表单的提交  
2. 重构HttpRequest类  
由于请求可能会传递参数过来,所以当我们解析请求时要对参数进行解析  
当一个页面中的form白鸥单以get形式提交时,所有form表单中的输入域内容会被拼接在地址栏中"?"右侧.  
这时我们在解析请求行中的url部分时会得到类似如下内容:  
/myweb/reg?username=xxx&password=xxx&....  
url中"?"右侧为参数部分,每个参数以"&"进行分割,每个参数由name=value组成,其中name是表单输入域的名字,value是该输入域输入的内容
  我们在HttpRequest中定义三个参数:        
  private String requestURI:保存url中的请求路径部分  
  private String queryString:保存url中的参数部分  
  private Map<String,String> parameter:保存每组参数  
  key:参数名  value:参数值  
    
    定义一个用来进一步解析url的方法:parseUrl,并在解析请求行paresRequestLine方法中解析出url后调用该方法,对url进一步解析.
    
# v11 支持注册业务  

当用户通过reg.html注册页面输入注册信息并点击注册按钮提交注册白鸥单信息后,服务端在解析该请求并再处理请求中添加分支判断,若该请求路径为请求注册业务,那么就应当实例化处理注册业务的逻辑类来完成该操作.  

实现:  
1. 我们在com.webserver包中新建一个包:servlets  
在这个包中我们定义将来服务端所支持的所有业务类
2. 在servlets包中定义处理注册业务的类:RegServlet  
并定义一个service方法,用来处理注册业务
3. 在ClientHandler处理请求的阶段添加一个分支判断,先根据请求路径requestURI来分析是否处理注册业务,若是,则实例化对应的业务类:RegServlet并调用其service方法来处理  
注意:我们不再使用HttpRequest中的url来判断请求了,因为url可能含有参数,而requestURI这个属性是请求的部分.
4. 在webapps/myweb目录中添加提示注册成功的页面:reg_success.html  
当RegServlet处理注册业务成功后,设置response响应此页面

# 12 实现登陆功能
1. 在webapps/myweb目录下新建三个页面:  
login.html:登陆页面  
该页面要求用户输入用户名和密码,form表单提交的action="login"  
login_success.html:登陆成功提示页面  
login_fail.html:登陆失败提示页面  

2. 在com.webserver.servlets包中添加一个类:LoginServlet  
并在该类中定义service方法(与RegServlet方法定义相同)  
在该方法中首先通过request获取用户名及密码  
然后通过RandomAccessFile读取user.dat文件,顺序读取每个用户的名字与该用户名比对若找到则比对密码  
若密码输入正确则跳转登陆成功页面.  
若密码输入错误则跳转登陆失败页面.

3. 在ClientHandler中判断处理注册业务的分支之下再添加一个分支  
判断请求路径是否为:/myweb/login  
若是则实例化LoginServlet并调用其service方法处理登陆

# v13 解决地址栏传递中文问题

由于HTTP协议要求,其协议内出现的字符串不允许使用中文(因为HTTP协议使用的是ISO8859-1编码,这是欧洲的编码集,不支持中文),因此,我们常见的解决办法为将中文按照UTF-8编码转换为3个字节,然后每个字节以"%xx"的三个字符形式表示一个字节,然后讲这些内容拼接在地址栏中传递.(%XX这里的内容为2位16禁止,2位16进制可以表示一个8位2进制[00000000],因此2位16进制表示1字节内容[00000000]这就是一字节,%XX的第一个x表示前四个0,第二个X表示后四个0)  
下面为例子


中文:  摩

|2进制|10进制|16进制|
|:------:|:------:|:------:|
| 11100110 | 230 | E6 | 
| 10010001 | 145 | 91 | 
| 10101001 | 169 | A9 | 
中文"摩"字在UTF-8里的编码为三个字节11100110 10010001 10101001  
所以转换成16进制则为%E6%91%A9

我们不需要自己去转换,java API提供了对字符串中含有的"%XX"解析的类,我门直接使用即可对url中的中文进行还原,这个类叫URLDecoder

# v14使得服务端支持post请求(这里只支持post请求提交的表单数据)
在实际开发中,当表单中包含用户隐私信息,或者上传附件等操作时一定要使用post请求.

对此我们将这些form表单提交的形式改为post,而当表单提交形式变为post后,所有输入域的内容不会再被拼接到URL的"?"右侧.而是将原"?"右侧内容包含再消息正文中被提交.

1. 将表单的提交方式改为post
2. 当比偶暗淡提交后,浏览器地址栏中不再包含"?"以及参数部分.而这部分内容会被包含在请求的消息正文中  
这时解析请求的消息头部分会发现多出两个头:
Content-Length=XX
Content-Type=application/x-www-form-urlencoded
分别告知浏览器消息正文长度以及正文内容的类型.
"application/x-www-form-urlencoded"是一个固定值,是用来表示此消息正文内容是一个字符串,是原get请求中"?"右侧的内容

完成HttpRequest类中解析消息正文的方法:parseContent  
解析消息正文前首先判断消息头中是否含有Content-Length,若有则说明这个请求包含消息正文  

获取消息头Content-Length的值,然后通过输入流读取对应长度的字节量

再获取消息头Content-Type,判断此正文的类型,这里只判断是否为页面form表单提交上来的用户输入的数据:
application/x-www-form-urlencoded  
如果是,则将读取的正文字节转换为一个数组,并进行解析参数操作

# v15 重构代码
由于所有的Servlet都要有处理业务操作的方法:service,因此我们定义一个抽象类:HttpServlet,并定义此抽象方法service,这样将来所有的Servlet都继承该类时就一定会重写此方法了.

1. 我们在servlets包中定义抽象类HttpServlet
2. 修改所有的Servlet类,让他们继承HttpServlet

# v16 使服务端支持重定向  

响应客户端时，我们通常有两种模式
1. 内部跳转
2. 重定向  
举例:当用户提交表单请求注册操作，服务端在处理完注册业务后直接响应客户端注册结果的页面，这种响应方式就是内部跳转。  
从业务逻辑直接跳转到结果页面，对于浏览器而言，它当前地址栏的路径是提交注册请求。而实际看到的是注册结果页面。  
这样有一个弊端，就是当用户点击刷新按钮再次发起请求时，会将表单再次提交，经过注册业务,这会给服务端带来无谓的资源开销。  
--  
这时建议采取使用重定向方式响应客户端，即:  
当用户提交表单后，服务端处理完毕响应给客户端一个路径，当客户端接收到该路径后继续按照该路径再次发起请求而得到注册结果页面.  
这时浏览器上地址栏应当是专门请求注册结果页面的路径了，这样无论怎么刷新，都不会再经过注册业务。

3. 实现重定向  
响应客户端时，重定向的方式需要响应状态代码:302  
并且在响应头中指定:Location对应的值就是希望客户端再次发起请求时的路径。  
该响应可以不包含响应正文。

# v17 使用映射来让Servlet更加灵活

问题:  
之前我们在ClientHandler中判断uri的值是否对应一个业务时,添加了很多的分支.这样做有一个弊端:每当我们添加一个新的业务时,都要修改ClientHandler,添加新的分支,将uri与该Servlet对应  

解决办法:  
让ClientHandler得到一个uri后,查看该uri是否对应一个Servlet,如果对应,得到该Servlet名字并动态加载,然后实例化.之后调用其service方法.  
而uri是否对应某个Servlet我们可以利用一个Map来维护,其中Key为uri,Value为对应的Servlet名字.并且这个对应关系可以用一个xml文件来维护,那么每当我们多一个新业务时,我们只需要在该xml文件中添加一个新的uri与Servlet的对应关系即可.  


这样一来,ClientHandler就无需再进行修改
